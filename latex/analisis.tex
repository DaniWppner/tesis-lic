%A pesar de que Manticore permita el uso de valores simbólicos para el parámetro \texttt{(msg.sender)} las limitaciones de la herramienta exigen que se defina cada account individualmente para que sea considerada en el estado de la blockchain.
Las limitaciones de la herramienta exigen que el parámetro \texttt{(msg.sender)}, a pesar de que pueda ser simbólico, se corresponda con una \textit{account} definida explícitamente por el usuario.
Por esto en la simulación contamos con un número fijo de \textit{accounts}, asignando variables simbólicas únicamente la información asociada a ellas (Dirección, Balance, etc).

\section{Comparación de las abstracciones generadas entre el algoritmo clásico y el alternativo}
Como mencionamos en la sección \ref{sec:subaproximacion}, las abstracciones generadas por el algoritmo alternativo no siempre son Enabledness Preserving Abstractions\footnote{Es decir, en algunos casos no cumplen la definición presentada en la sección \ref{definicion-epa}.} de los contratos analizados, sino que son unas subaproximaciones de estas.
Al mismo tiempo, las EPAs son sobreaproximaciones del comportamiento de los contratos, por lo que el mecanismo resultante del algoritmo alternativo yace en algún lugar intermedio: no es ni sound ni complete.
Por esto, nos interesa explorar en particular cuáles son las diferencias producidas entre el algoritmo alternativo y las generadas por el algoritmo clásico (las EPAs) para evaluar su utilidad.
Para responder estas preguntas analizamos el desempeño de los prototipos implementados usando ambos algoritmos sobre algunos casos de prueba.

\subsection{Caso \texttt{RoomThermostat}}
El primer caso que evaluamos fue el contrato \texttt{RoomThermostat} perteneciente al benchmark ``Microsoft Azure Blockchain Workbench" \cite{azure-benchmark}, cuyo código fuente podemos ver en la figura \ref{fig:rooomthermostat-solidity}.
Es un contrato pequeño, con pocos métodos y un invariante sencillo.
Para poder emplear el algoritmo clásico sobre este contrato, el invariante propuesto fue el siguiente:
\begin{lstlisting}[language=Solidity]
    function invariant(StateType stateNew, address installerNew, address userNew, int targetTemperatureNew, ModeEnum modeNew) public returns(bool){
        bool result = (stateNew == StateType.Created || stateNew == StateType.InUse);
        result = result && (modeNew == ModeEnum.Auto || modeNew == ModeEnum.Cool || modeNew == ModeEnum.Heat || modeNew == ModeEnum.Off);
        if(stateNew == StateType.Created){
            result = (targetTemperatureNew == 70) && (modeNew == ModeEnum.Off);
        }
        return result;
    }
\end{lstlisting}

Luego, evaluamos tanto el algoritmo clásico como el alternativo sobre el contrato.
En ambos casos la EPA generada fue la misma, una máquina de estados sencilla de tan sólo tres estados que podemos ver en la figura \ref{fig:room-thermostat-epa}.

\begin{figure}
    \centering
    \begin{subfigure}{0.75\textwidth}
        \includegraphics[width=\textwidth]{figs/room-thermostate-epa.png}
        \caption{Enabledness Preserving Abstraction del contrato \texttt{RoomThermostat} }
        \label{fig:room-thermostat-epa}
    \end{subfigure}
\end{figure}

\subsection{Caso \texttt{BoundedStack}}
El siguiente caso que evaluamos fue el ejemplo teórico que expusimos en la sección \ref{sec:subaproximacion}, el contrato \texttt{BoundedStack}, con intención de evidenciar las subaproximaiones realizadas por el algoritmo nuevo.
El código del contrato se encuentra en la imagen \ref{code:solidity-bounded-stack}.
Nos interesa corroborar el comportamiento de ambos algoritmos, si se produce alguna subaproximación, y cuáles.

Lo primero que vimos al evaluar la abstracción generada por el algoritmo alternativo sobre el contrato \texttt{BoundedStack} lo podemos ver en la imagen \ref{fig:buggy-bounded-stack-epa}.
En esa abstracción  podemos ver que faltan algunas de las transiciones presentes en la EPA del contrato, pero además podemos observar que las transiciones por \textcolor{orange}{\texttt{pop}} siempre llevan al estado desde el que se ejecutó el método.
Cuando realizamos esta comparación generó bastante confusión, hasta que comprendimos que se debía a un error en el código fuente de \texttt{BoundedStack} que no decrementaba la variable \texttt{size} al ejecutar \textcolor{orange}{\texttt{pop}}.
Luego de corregir el error, la abstracción generada por el prototipo fue la referenciada en la imagen \ref{fig:bounded-stack-bad-epa}.
Es decir, la misma que elaboramos durante el ejemplo teórico del comportamiento del algoritmo alternativo.
Decidimos incluir este pequeña caso de un error en el código fuente en lugar de omitirlo para ejemplificar que, a pesar de que quede evidenciado que el algoritmo nuevo genere subaproximaciones de las EPAs en la práctica, las abstracciones generadas pueden seguir resultando útiles a la hora de atrapar errores.

\begin{figure}[H]
    \centering
    \begin{subfigure}{0.45\textwidth}
        \includegraphics[width=\textwidth]{figs/buggy-bounded-stack-epa.png}
        \caption{Enabledness Preserving Abstraction del contrato \texttt{BoundedStack} con un error que no decrementa el tamaño luego de ejecutar \textcolor{orange}{\texttt{pop}} }
        \label{fig:buggy-bounded-stack-epa}
    \end{subfigure}
\end{figure}

A la hora de emplear el algoritmo clásico sobre el contrato, el invariante propuesto fue el siguiente:
\begin{lstlisting}[language=Solidity]
    function invariant() public returns(bool){
        bool result = (size >= 0) && (size <= maxSize);
        result = result && (internal_arr.length == size);
        return result;
    }
\end{lstlisting}

Sin embargo, el prototipo desarrollado con el algoritmo clásico no pudo analizar este contrato satisfactoriamente, sino que terminó el analisis por time out.
Esto se debe a que el paso de restringir las instancias del contrato a aquellas que satisfagan el invariante resultó demasiado difícil para el motor de ejecucion simbólica de Manticore
Algunos experimentos y análisis intermedios nos hacen creer que se debe a la pobre representación de las variables de tipo \textcolor{cyan}{\texttt{uint256[]}} del mismo.
Esto significó que terminamos el análisis comparando la abstracción generada por el algoritmo alternativo no con la generada por el algoritmo clásico, sino con una EPA producida manualmente.

\section{Comparación en tiempo de ejecución entre el algoritmo clásico y el alternativo}
Otra hipótesis generada durante el desarrollo del algoritmo alternativo fue que el evitar la ejecución de los invariantes mejoraría el tiempo de ejecución.
Esto se debe a que los invariantes, comparadas con las precondiciones de los métodos externos, son propiedades relativamente complejas que además pueden hablar sobre el estado de variables internas de tipos complejos como arrays, mappings, etc.
Para evaluar esta hipótesis estudiamos el tiempo de ejecución empleado por los prototipos que implementan el algoritmo alternativo y el clásico en Manticore sobre algunos de los contratos pertenecientes al benchmark Microsoft Azure Blockchain Workbench \cite{azure-benchmark}.

Ya que este mismo benchmark había sido utilizado por Godoy et al. en 2022 \cite{predicate-abstraction-for-smart-contract-validation}, a la hora de experimentar contamos con EPAs de todos los contratos involucrados, por lo que además pudimos usarlas para corroborar la correctitud de las abstracciones generadas.
Los experimentos fueron realizados ejecutando ambos prototipos sobre cada contrato cinco veces y luego tomando el promedio del tiempo total de ejecución.
Todas las mediciones fueron realizadas en una máquina en una máquina \textcolor{red}{\textbf{DESCRIPCION MAQUINA}}.

En la figura \ref{fig:classic-vs-alternativo} podemos ver los resultados del experimento realizado.
Las mediciones fueron solo realizadas para los contratos \texttt{DefectiveComponentCounter}, \texttt{RoomThermostat}, \texttt{BasicProvenance} y \texttt{SimpleMarketplace} porque como podemos ver el tiempo de ejecución de la implementación del algoritmo clásico nunca fue menor a diez horas.
A pesar de que en todos los contratos analizados podamos ver una diferencia significativa al emplear el algoritmo alternativo, es importante destacar que los tiempos de ejecución de esta técnica aún se mantuvieron muy altos.
La mejora en tiempo parecería ser relativamente constante a lo largo de los cuatro contratos analizados, habiendo tardado el algoritmo alternativo alrededor de diez horas menos que el clásico.
Esta diferencia cercana a constante posiblemente se deba a que todos los contratos eran muy simples (recordemos la baja cantidad de métodos externos en \texttt{SimpleMarketplace} y \texttt{RoomThermostat}), por lo que no se pudo observar la diferencia en comportamiento que habría en contratos más complejos.

A pesar de que la mejora del algoritmo alternativo frente al clásico fuese tan grande, los valores obtenidos con el algoritmo alternativo siguieron sin resultar razonables.
Si observamos los valores obtenidos, el tiempo de cómputo en promedio fue de entre media hasta casi tres horas, lo que no resulta aplicable para un usuario de la herramienta que pretenda generar las abstracciones en tiempo real.
Por este motivo decidimos realizar los experimentos que mostraremos a continuación, en los que buscamos conseguir mejoras en el tiempo de ejecución o claridad en la razón de que tarde tanto.

\begin{figure}
    \centering
    \begin{subfigure}{0.65\textwidth}
        \includegraphics[width=\textwidth]{figs/classic_vs_alternativo.png}
        \caption{Tiempo de ejecución (en promedio) de la generación de abstracciones del prototipo que implementa el algoritmo alternativo y el algoritmo clásico}
        \label{fig:classic-vs-alternativo}
    \end{subfigure}
\end{figure}

\section{Evaluación más detallada del tiempo de ejecución del algoritmo alternativo}
Para mejorar el tiempo de ejecución del prototipo buscamos identificar en qué partes del análisis era que se consumía la mayor parte del tiempo empleado.
Lo primero que hicimos fue identificar ``etapas'' en el algoritmo alternativo que pudimos diferenciar para medir el tiempo empleado en cada una de ellas.
Por otro lado analizamos el código fuente de Manticore y diferenciamos en distintos niveles de abstracción las funcionalidades que estábamos usando.

Separamos la ejecución del prototipo en tres etapas:
\begin{enumerate}
    \item El desplegado simbólico del contrato
    \item La ejecución simbólica de los métodos
    \item La solución de queries de satisfacibilidad sobre las transiciones en la EPA
\end{enumerate}
Donde notoriamente el algoritmo alternativo comienza en la etapa 1., y luego alterna entre la etapa 3. y la 2. hasta finalizar.

A continuación indicamos cuál fue la división en niveles de abstracción que hicimos de las funcionalidades de Manticore.
En particular, por como es la arquitectura de multithreading y \textbf{\texttt{workers}} de Manticore, solo pudimos hacer esta distinción en los métodos relacionados a la resolución de valores simbólicos.
La manera en la que se realizaba la ejecución simbólica y la generación de las path conditions era demasiado dependiente de objetos creados dinámicamente como para poder recibir el mismo tipo de análisis.
\begin{enumerate}
    \item \textbf{Nivel Externo}\footnote{En el momento de realizar las mediciones, los valores para este nivel se registraron bajo el nombre de  ``Nivel 3''} : utilizado para medir el tiempo que consumían las funciones de la API de manticore que nuestro prototipo llamaba directamente.
          La única función cuyo tiempo medimos en este nivel fue \texttt{generateTestcases}.
    \item \textbf{Nivel \texttt{state}} : Utilizado en las funciones del módulo \textbf{\texttt{state}} que identificamos que eran llamadas.
          Los métodos registrados bajo este nivel fueron \texttt{can\_be\_true} y \texttt{solve\_\allowbreak one\_\allowbreak n\_\allowbreak batched}.
    \item \textbf{Nivel SMT solver} : Utilizado en alrededor de cada llamado directo al SMT solver en los métodos del módulo \textbf{\texttt{smtlib}}.
          Los métodos registrados bajo este nivel fueron \texttt{\_is\_sat}, \texttt{\_get\_value} y \texttt{\_\_get\_value\_all}.
\end{enumerate}
Cada uno de los métodos fue modificado para medir el tiempo desde el principio de la zona de interés hasta el fin de la misma.
Por ejemplo, en la figura \ref{code:getvalueall-modification} podemos ver los cambios introducidos al método \texttt{\_\_get\_value\_all} para registrar el tiempo.

\begin{lstlisting}[language=Python,
    label={code:getvalueall-modification},
    caption=\text{Método \texttt{\_\_get\_value\_all} del modulo \textbf{\texttt{smtlib}} modificado para registrar el tiempo empleado por la llamada al SMT solver. El resaltado indica las líneas agregadas para registrar el tiempo.},
    captionpos=b]
def __getvalue_all(self, expressions_str: List[str], is_bv: List[bool]) -> Dict[str, int]:
    (*@| \hl{start = time.time()} |@*)
    all_expressions_str = " ".join(expressions_str)
    self._smtlib.send(f"(get-value ({all_expressions_str}))")
    ret_solver: Optional[str] = self._smtlib.recv()
    (*@| \hl{print}|@*)(f"(level _getvalue_all_z3_call) took {time.time()- start} seconds")
    assert ret_solver is not None
    return_values = re.findall(RE_GET_EXPR_VALUE_ALL, ret_solver)
    
    return {value[0]: _convert(value[1]) for value in return_values}
\end{lstlisting}

De  entre los métodos a los que les registramos el tiempo de ejecución, sabíamos que los métodos en \textbf{Nivel Externo} solo eran ejecutados cuando el prototipo implementado los llamaba explícitamente.
Por otro lado, los métodos en \textbf{Nivel \texttt{state}} eran métodos que a veces eran llamados dsde la implementación directamente, pero además eran ejecutados como métodos internos de otros procesos durante el análisis.
Por último, los métodos del \textbf{Nivel SMT solver} eran ejecutados en diversos momentos del análisis.

Una vez hecha esta separación en etapas del algoritmo y niveles de abstracción que nos resultaba de interés investigar, medimos el tiempo total en promedio empleado por cada etapa y cada nivel de abstracción en una ejecución del prototipo.
Para esto, al igual que antes, analizamos el rendimiento en los contratos \texttt{DefectiveComponentCounter}, \texttt{RoomThermostat}, \texttt{BasicProvenance} y \texttt{SimpleMarketplace} del benchmark Microsoft Azure Blockchain Workbench \cite{azure-benchmark}.
Por otro lado, además, calculamos para cada uno de los niveles de abstracción diferenciados la cantidad de veces que este mismo fue registrado y el tiempo total empleado.
Esto fue para intentar percibir discrepancias entre los niveles que espérabamos que consumieran la mayoría del tiempo y lo que pudiéramos medir.

En la figura \textcolor{red}{\textbf{dani hace la figura escribila}} podemos ver los resultados obtenidos de estas mediciones.


Al evaluar el funcionamiento del prototipo buscamos responder las siguientes preguntas:
\begin{enumerate}
    \item ¿Son correctas las EPAs que genera el prototipo?
    \item ¿Cuál es su performance en contratos inteligentes reales?
\end{enumerate}
Para responder estas preguntas, pusimos el prototipo a prueba contra algunos contratos provenientes de Microsoft Azure Blockchain Workbench \cite{azure-benchmark}.
Este conjunto de contratos había sido utilizado anteriormente por Godoy et al. \cite{predicate-abstraction-for-smart-contract-validation}, por lo que convenientemente ya contamos con las EPAs correspondientes.
Ejecutamos el prototipo cinco veces, obteniendo el promedio de su tiempo de ejecución sobre los contratos seleccionados y luego corroboramos que la EPA generada fuera isomórfica a la obtenida en los estudios anteriores.
%Además, pusimos a prueba la cantidad de accounts necesarias para el funcionamiento del prototipo.
Los resultados intermedios indicaron que para los contratos propuestos era suficiente realizar la simulación con dos \textit{accounts}, por lo que utilizamos esa cantidad para los experimentos.
Los resultados de esta experimentación se ven resumidos en la tabla \ref{tab:resultados}.
El prototipo generó EPAs correctas en todos los casos.
Sin embargo, el tiempo de cálculo es de entre media y casi tres horas, considerando incluso que los ejemplos utilizados son relativmente pequeños.
Algunos resultados intermedios indican que este tiempo es consumido principalmente por Manticore para la generación de \textit{path conditions}.
Debido a la rigurosidad con la que emula Manticore el comportamiento de la blockchain, la herramienta demora incluso para la ejecución simbólica de transiciones sencillas.

\vspace{-2.2em}

\begin{table}
    %\begin{adjustwidth}{-0.5in}{-0.5in}% adjust the L and R margins by 1 inch
    \caption{Resumen de la experimentación. \textbf{LOC} es cantidad de lineas de código, \textbf{Tiempo de ejecución} es el promedio del tiempo de ejecución medido en minutos, $\boldsymbol{\sigma}$ es el desvío estandard medido en segundos y \textbf{¿Es correcto?} indica si la EPA generada es isomorfa con la provista anteriormente.}\label{tab:resultados}
    \begin{tabular}{|l|l|l|l|l|}
        \hline
        Contrato                  & LOC & Tiempo de ejecución (min) & $\sigma$ (s) & ¿Es correcto? \\
        \hline
        DefectiveComponentCounter & 33  & $29$                      & $7$          & Sí            \\
        SimpleMarketplace         & 66  & $186$                     & $800$        & Sí            \\
        BasicProvenance           & 48  & $40$                      & $6$          & Sí            \\
        RoomThermostat            & 48  & $138$                     & $600$        & Sí            \\
        \hline
    \end{tabular}
    %\end{adjustwidth}
\end{table}
